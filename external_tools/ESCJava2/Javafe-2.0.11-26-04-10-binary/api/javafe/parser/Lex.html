<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_17) on Mon Apr 26 15:05:18 CEST 2010 -->
<TITLE>
Lex (Javafe)
</TITLE>

<META NAME="date" CONTENT="2010-04-26">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../javafe.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Lex (Javafe)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lex.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Javafe<br />&copy; 2010 IT University of Copenhagen<br />&copy; 2007,2008,2009,2010 Joseph Kiniry<br/>&copy; 2003,2004,2005,2006 David Cok and Joseph Kiniry<br />&copy; 2005,2006,2007,2008,2009 University College Dublin<br />&copy; 2003,2004 Radboud University Nijmegen<br />&copy; 1999,2000 Compaq Computer Corporation<br />&copy; 1997,1998,1999 Digital Equipment Corporation<br />All Rights Reserved</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javafe/parser/FileFormatException.html" title="class in javafe.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javafe/parser/Parse.html" title="class in javafe.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javafe/parser/Lex.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lex.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javafe.parser</FONT>
<BR>
Class Lex</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">javafe.parser.ParserToken</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javafe.parser.Lex</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <A HREF="../../src-html/javafe/parser/Lex.html#line.200"><B>Lex</B></A><DT>extends <A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A></DL>
</PRE>

<P>
A <TT>Lex</TT> object generates a sequence of Java "input elements"
 (that is, tokens) by converting the sequence of input characters and
 line terminators generated by an underlying
 <code>CorrelatedReader</code>.

 <p> The conversion of input characters occurs according to the lexical
 rules in Chapter Three of the <cite>Java Language
 Specification</cite>.  This specification describes three lexical
 translation steps: the first two steps translate a raw Unicode input
 stream into a "cooked" one in which Unicode escape characters from the
 raw stream have been processed and in which line terminators have been
 identified; the last step translates this cooked stream into a
 sequence of Java "input elements" (comments, white space, identifiers,
 tokens, literals, and punctuation).  <code>Lex</code> objects perform
 the last of these translations steps; the first two are performed by
 an underlying <code>CorrelatedReader</code> that is given to the
 <code>Lex</code> object as the source of input characters.

 <p> Before a newly-created <code>Lex</code> object can be used, its
 <code>restart</code> method must be called giving a
 <code>CorrelatedReader</code> to scan.  At any point, a
 <code>Lex</code> can be restarted on a different underlying reader.

 <p> The <TT>Lex</TT> class is thread safe, but instances of
 <TT>Lex</TT> are not.  That is, two different threads may safely
 access two different instances of <TT>Lex</TT> concurrently, but they
 may not access the same instance of <TT>Lex</TT> concurrently.


 <h3> Simple scanning </h3>

 <p> The <code>getNextToken</code> method of <code>Lex</code> objects
 returns the translated token sequence, one token at a time.  It
 discards white space, and it processes comments as described below.
 In addition, <code>getNextToken</code> fills in the <code>Token</code>
 fields of <code>this</code> (<code>Lex</code> is a subclass of
 <code>Token</code>); for example, <code>ttype</code> gets an integer
 code defining the type of token returned and <code>startingLoc</code>
 gives the location of the first character making up the token.  If the
 token is an identifier, <code>identifierVal</code> indicates which
 one; if the token is a literal, <code>auxVal</code> gives its value.

 <p> <code>Lex</code> objects report errors by calling both the
 <code>fatal</code> and <code>error</code> methods of
 <code>ErrorSet</code>.  The fatal errors are unexpected characters,
 unterminated comments and string and character literals, and IO errors
 in the underlying input stream.  Recoverable errors are overflows in
 literals (including overflows in octal escape sequences), non-octal
 digits in integer literals, the string <code>0x</code> (interpreted as
 a malformed integer literal), missing digits in a floating-point
 exponent, bad escape sequences in character and string literals,
 character literals containing no or multiple characters, and the
 character literal <code>'''</code> (interpreted as <code>'\''</code>).


 <h3> Lookahead </h3>

 <code>Lex</code> objects allow their clients to peek ahead into the
 token stream by calling <code>lookahead</code>.  This method returns
 the token code for the future token, but it does not affect the
 <code>Token</code> fields of <code>this</code>.

 <p> If a call to <code>lookahead</code> needs to look past the set of
 tokens already scanned, and those tokens have errors, then the errors
 are reported immediately.


 <h3> Extensibility: Keywords, punctuation </h3>

 <p> A keyword is a Java identifier with a special token code.
 Ordinarily, identifiers are associated with the code
 <code>TagConstants.IDENT</code>.  Keywords, while matching the lexical
 grammar of identifiers, are associated with different codes.  In fact,
 each keyword is typically associated with its own code.

 <p> The set of identifiers that a <code>Lex</code> object recognizes
 as keywords is extensible.  A keyword is added to a <code>Lex</code>
 object by calling the <code>addKeyword</code> method.  As a
 convenience, a boolean given to the <code>Lex</code> constructor
 indicates whether a newly-constructed <code>Lex</code> object should
 automatically have all Java keywords added to it.

 <p> A punctuation string is a string of punctuation characters
 recognized by a <code>Lex</code> object to be a token.  (Punctuation
 characters are non-alphanumeric ASCII characters whose ASCII codes are
 between 33 ('!')  and 126 ('~') inclusive.)  As with keywords, the set
 of punctuation strings recognized by a <code>Lex</code> object is
 extensible.  A punctuation string is added to a <code>Lex</code>
 object by calling the <code>addPunctuation</code> method.  A boolean
 given to the <code>Lex</code> constructor indicates whether a
 newly-constructed <code>Lex</code> object should automatically have
 all Java punctuation strings added to it.


 <h3> Extensibility: comments and pragmas </h3>

 <p> The handling of comments is special in two ways: the punctuation
 strings that start comments is extensible, the text of comments can be
 parsed for pragmas.

 <h5> Comment recognition </h5>

 <p> Ordinarily, keywords and punctuation strings are mapped to token
 codes that are returned by calls to <code>getNextToken</code>.
 However, two token codes are treated specially:
 <code>TagConstants.C_COMMENT</code> and <code>TagConstants.EOL_COMMENT</code>.
 These codes are used to indicate the start of C-like comments
 (<code>/*...*</code><code>/</code>) and end-of-line comments
 (<code>//...</code>), respectively.  When a keyword or punctuation
 string is mapped to these codes, it is handled like a comment
 initiator rather than a regular token.

 <p> For all newly-created <code>Lex</code> objects, <code>/*</code> is
 mapped to <code>TagConstants.C_COMMENT</code> and <code>//</code> is mapped
 to <code>TagConstants.EOL_COMMENT</code>.  Other punctuation strings can be
 made comment initiators by mapping them to comment-initiating codes.
 This is more useful for <code>TagConstants.EOL_COMMENT</code> than for
 <code>TagConstants.C_COMMENT</code>, since the string
 <code>*</code><code>/</code> is hard-wired as the terminator of C-like
 comments.

 <h5> Pragma parsing </h5>

 <code>Lex</code> objects are designed to support annotation of Java
 programs through pragmas.  A <a href = "../pragma-handling.html">
 separate document </a> describes our overall aproach to pragmas.  In
 brief, our front-end supports two kinds of pragmas: control pragmas
 that can appear anywhere in an input file and are collected in a list
 apart from the parse tree, and syntax pragmas that can only appear in
 certain grammatical contexts and become part of the parse tree.
 Pragmas always appear in Java comments, at most one pragma per
 comment.  These comments must have one of the following forms:

 <menu>
 <li> <code>/*</code><i>tag</i> <i>white-space</i> <i>pragma-text</i><code>*</code><code>/</code>
 <li> <code>//</code><i>tag</i> <i>white-space-minus-EOL</i> <i>pragma-text</i> <i>EOL</code>
 </menu>

 <p> When a <code>Lex</code> object is created, it can optionally be
 associated with a <code>PragmaParser</code> object.  If a
 <code>Lex</code> object has no <code>PragmaParser</code>, it discards
 all comments.  Otherwise, the <code>Lex</code> object passes the first
 character of the comment (or -1 if the comment is empty) to the
 <code>checkTag</code> method of the <code>PragmaParser</code> object,
 which returns <code>false</code> if the comment definitely does not
 contain any pragmas.  If the comment may contain pragmas, the
 <code>Lex</code> object bundles the text between the delimiters of a
 comment into a <code>CorrelatedReader</code> which it passes to the
 <code>restart</code> method of its <code>PragmaParser</code>.  (This
 text excludes both the opening <code>/*</code> or <code>//</code> and
 the closing <code>*</code><code>/</code> or line terminator.)

 <p> The <code>Lex</code> object then calls <code>getNextPragma</code>
 to read the pragmas out of the comment one at a time.  The
 <code>Lex</code> object does this in a lazy manner; that is, it reads
 a pragma, returns it to the parser, and waits until the parser calls
 for the next token before it attempts to read another pragma.  The
 <code>getNextPragma</code> method returns a boolean, returning
 <code>false</code> if there are no more pragmas to be parsed.  The
 <code>getNextPragma</code> method takes a <code>Token</code> as an
 argument, storing information about the pragma parsed into this
 argument.

 <p> When <code>PragmaParser.getNextPragma</code> returns a
 <code>LexicalPragma</code>, the <code>Lex</code> object puts it in an
 internal list rather than returning it to the parser.  The list of
 collected lexical pragmas can be retrieved by calling
 <code>getLexicalPragmas</code>.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../javafe/util/CorrelatedReader.html" title="class in javafe.util"><CODE>CorrelatedReader</CODE></A>, 
<A HREF="../../javafe/parser/ParserTagConstants.html" title="class in javafe.parser"><CODE>ParserTagConstants</CODE></A>, 
<A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser"><CODE>ParserToken</CODE></A>, 
<A HREF="../../javafe/parser/PragmaParser.html" title="interface in javafe.parser"><CODE>PragmaParser</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#inPragma">inPragma</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#javakeywords">javakeywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#keywords">keywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unenforceable invariant: all tokenTypes in this table do not
 require a non-null auxVal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/LexicalPragmaVec.html" title="class in javafe.ast">LexicalPragmaVec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lexicalPragmas">lexicalPragmas</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/parser/TokenQueue.html" title="class in javafe.parser">TokenQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lookaheadq">lookaheadq</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/util/CorrelatedReader.html" title="class in javafe.util">CorrelatedReader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#m_in">m_in</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current state of input stream underlying the scanner minus the
 first character.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#m_nextchr">m_nextchr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Each call to <code>getNextToken</code> reads ahead one character
     and leaves the result in <code>m_nextchr</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#onlyjavakeywords">onlyjavakeywords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/parser/PragmaParser.html" title="interface in javafe.parser">PragmaParser</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#pragmaParser">pragmaParser</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;<A HREF="../../javafe/parser/PunctuationPrefixTree.html" title="class in javafe.parser">PunctuationPrefixTree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#punctuationTable">punctuationTable</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#savedState">savedState</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#stringLit">stringLit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#stringLitLen">stringLitLen</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;char[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#text">text</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The characters that constitute the current token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#textlen">textlen</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of characters in the current token.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javafe.parser.ParserToken"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class javafe.parser.<A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javafe/parser/ParserToken.html#auxVal">auxVal</A>, <A HREF="../../javafe/parser/ParserToken.html#CLEAR">CLEAR</A>, <A HREF="../../javafe/parser/ParserToken.html#endingLoc">endingLoc</A>, <A HREF="../../javafe/parser/ParserToken.html#identifierVal">identifierVal</A>, <A HREF="../../javafe/parser/ParserToken.html#startingLoc">startingLoc</A>, <A HREF="../../javafe/parser/ParserToken.html#ttype">ttype</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#Lex(javafe.parser.PragmaParser, boolean)">Lex</A></B>(<A HREF="../../javafe/parser/PragmaParser.html" title="interface in javafe.parser">PragmaParser</A>&nbsp;pragmaParser,
       boolean&nbsp;isJava)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a lexical analyzer that will tokenize the characters
 read from an underlying <code>CorrelatedReader</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addJavaKeywords()">addJavaKeywords</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all of Java's keywords to the scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addJavaPunctuation()">addJavaPunctuation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add all of Java's punctuation strings to the scanner.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addKeyword(java.lang.String, int)">addKeyword</A></B>(java.lang.String&nbsp;newkeyword,
                     int&nbsp;code)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a keyword to a <code>Lex</code> object with the given code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#addPunctuation(java.lang.String, int)">addPunctuation</A></B>(java.lang.String&nbsp;punctuation,
                             int&nbsp;code)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a punctuation string to a scanner associated with a given
     code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#append(int)">append</A></B>(int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Append 'c' to <CODE>text</CODE>, expanding if necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes the <code>CorrelatedReader</code> underlying
     <code>this</code>, clears the set of collected lexical pragmas,
     and in other ways frees up resources associated with
     <code>this</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#finishFloatingPointLiteral(int)">finishFloatingPointLiteral</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finishes scanning a floating-point literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/LexicalPragmaVec.html" title="class in javafe.ast">LexicalPragmaVec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#getLexicalPragmas()">getLexicalPragmas</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the set of lexical pragmas collected.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#getNextToken()">getNextToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans next token from input stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lookahead(int)">lookahead</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns token type of the <TT>k</TT>th future token, where k=0
     is the current token.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#lookaheadToken(int)">lookaheadToken</A></B>(int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javafe/ast/LexicalPragma.html" title="class in javafe.ast">LexicalPragma</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#popLexicalPragma()">popLexicalPragma</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove the first LexicalPragma from our set of lexical pragmas
 collected, returning it or null if our set is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#replaceLookaheadToken(int, javafe.parser.ParserToken)">replaceLookaheadToken</A></B>(int&nbsp;k,
                                           <A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#restart(javafe.util.CorrelatedReader)">restart</A></B>(<A HREF="../../javafe/util/CorrelatedReader.html" title="class in javafe.util">CorrelatedReader</A>&nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start scaning a new <code>CorrelatedReader</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanCharOrString(int)">scanCharOrString</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scan a character or string constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanComment(int)">scanComment</A></B>(int&nbsp;commentKind)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handle a comment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanJavaExtensions(int)">scanJavaExtensions</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans a Java extension.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanNumber(int)">scanNumber</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans a numeric literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanPunctuation(int)">scanPunctuation</A></B>(int&nbsp;nextchr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scans a punctuation string <em>or</em> a floating-point
     number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#scanToken()">scanToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the code of the next token in the token stream, updating
     the <code>Token</code> fields of <code>this</code> along the way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>private &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#stringLitAppend(int)">stringLitAppend</A></B>(int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javafe/parser/Lex.html#zzz(java.lang.String)">zzz</A></B>(java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks invariants (assumes that <CODE>Token</CODE> fields
     haven't been mucked with by outside code).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javafe.parser.ParserToken"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class javafe.parser.<A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javafe/parser/ParserToken.html#clear()">clear</A>, <A HREF="../../javafe/parser/ParserToken.html#copyInto(javafe.parser.ParserToken)">copyInto</A>, <A HREF="../../javafe/parser/ParserToken.html#ztoString()">ztoString</A>, <A HREF="../../javafe/parser/ParserToken.html#zzz()">zzz</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="m_in"><!-- --></A><H3>
m_in</H3>
<PRE>
protected <A HREF="../../javafe/util/CorrelatedReader.html" title="class in javafe.util">CorrelatedReader</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.211"><B>m_in</B></A></PRE>
<DL>
<DD>Current state of input stream underlying the scanner minus the
 first character.  See <code>m_nextchr</code>. <p>

 This is null iff we are closed.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="m_nextchr"><!-- --></A><H3>
m_nextchr</H3>
<PRE>
protected int <A HREF="../../src-html/javafe/parser/Lex.html#line.220"><B>m_nextchr</B></A></PRE>
<DL>
<DD>Each call to <code>getNextToken</code> reads ahead one character
     and leaves the result in <code>m_nextchr</code>.  In other words,
     between calls to <code>getNextToken</code>, the stream of
     characters yet-to-scanned consists of the character in
     <code>m_nextchr</code> followed by the characters remaining in
     <code>m_in</code>.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="text"><!-- --></A><H3>
text</H3>
<PRE>
protected char[] <A HREF="../../src-html/javafe/parser/Lex.html#line.239"><B>text</B></A></PRE>
<DL>
<DD>The characters that constitute the current token.  Only the
     first <TT>textlen</TT> characters are part of the current token;
     the actual length of <TT>text</TT> may be bigger.  The lexer may
     occasionally need to resize <TT>text</TT>, so the same array might
     not be used throughout the lifetime of the lexer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="textlen"><!-- --></A><H3>
textlen</H3>
<PRE>
protected int <A HREF="../../src-html/javafe/parser/Lex.html#line.248"><B>textlen</B></A></PRE>
<DL>
<DD>The number of characters in the current token.  The "current
     token" is the one parsed by the previous call to
     <TT>getNextToken</TT> (there is no "current token" between
     creation of a lexer and the first call to getNextToken).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lookaheadq"><!-- --></A><H3>
lookaheadq</H3>
<PRE>
protected final <A HREF="../../javafe/parser/TokenQueue.html" title="class in javafe.parser">TokenQueue</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.269"><B>lookaheadq</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="lexicalPragmas"><!-- --></A><H3>
lexicalPragmas</H3>
<PRE>
public <A HREF="../../javafe/ast/LexicalPragmaVec.html" title="class in javafe.ast">LexicalPragmaVec</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.271"><B>lexicalPragmas</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="pragmaParser"><!-- --></A><H3>
pragmaParser</H3>
<PRE>
protected <A HREF="../../javafe/parser/PragmaParser.html" title="interface in javafe.parser">PragmaParser</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.274"><B>pragmaParser</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="inPragma"><!-- --></A><H3>
inPragma</H3>
<PRE>
protected boolean <A HREF="../../src-html/javafe/parser/Lex.html#line.275"><B>inPragma</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="savedState"><!-- --></A><H3>
savedState</H3>
<PRE>
protected <A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.460"><B>savedState</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="stringLit"><!-- --></A><H3>
stringLit</H3>
<PRE>
private char[] <A HREF="../../src-html/javafe/parser/Lex.html#line.1150"><B>stringLit</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="stringLitLen"><!-- --></A><H3>
stringLitLen</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.1153"><B>stringLitLen</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="punctuationTable"><!-- --></A><H3>
punctuationTable</H3>
<PRE>
private <A HREF="../../javafe/parser/PunctuationPrefixTree.html" title="class in javafe.parser">PunctuationPrefixTree</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.1171"><B>punctuationTable</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="keywords"><!-- --></A><H3>
keywords</H3>
<PRE>
protected java.util.Hashtable <A HREF="../../src-html/javafe/parser/Lex.html#line.1181"><B>keywords</B></A></PRE>
<DL>
<DD>Unenforceable invariant: all tokenTypes in this table do not
 require a non-null auxVal.  (cf. Token.auxVal).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="javakeywords"><!-- --></A><H3>
javakeywords</H3>
<PRE>
protected boolean <A HREF="../../src-html/javafe/parser/Lex.html#line.1183"><B>javakeywords</B></A></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="onlyjavakeywords"><!-- --></A><H3>
onlyjavakeywords</H3>
<PRE>
protected boolean <A HREF="../../src-html/javafe/parser/Lex.html#line.1183"><B>onlyjavakeywords</B></A></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Lex(javafe.parser.PragmaParser, boolean)"><!-- --></A><H3>
Lex</H3>
<PRE>
public <A HREF="../../src-html/javafe/parser/Lex.html#line.298"><B>Lex</B></A>(<A HREF="../../javafe/parser/PragmaParser.html" title="interface in javafe.parser">PragmaParser</A>&nbsp;pragmaParser,
           boolean&nbsp;isJava)</PRE>
<DL>
<DD>Creates a lexical analyzer that will tokenize the characters
 read from an underlying <code>CorrelatedReader</code>.  Before
 the newly-created scanner can be used, its <code>restart</code>
 method must be called on a <code>CorrelatedReader</code>.  The
 <code>pragmaParser</code> object is used to parse pragmas out
 of comments; if it is <code>null</code>, all comments are
 discarded.  The <code>isJava</code> flag controls the initial
 set of keywords and punctuation strings; if <code>true</code>,
 the new scanner will recognize Java's keywords and punctuation
 strings, if <code>false</code>, the new scanner will recognize
 <em>no</em> keywords or punctuation strings.  If
 <code>isJava</code> is true, the token codes used for the
 Java's keywords and punctuation strings are those defined by
 the <code>TagConstants</code> class.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="append(int)"><!-- --></A><H3>
append</H3>
<PRE>
protected void <A HREF="../../src-html/javafe/parser/Lex.html#line.253"><B>append</B></A>(int&nbsp;c)</PRE>
<DL>
<DD>Append 'c' to <CODE>text</CODE>, expanding if necessary.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="restart(javafe.util.CorrelatedReader)"><!-- --></A><H3>
restart</H3>
<PRE>
public int <A HREF="../../src-html/javafe/parser/Lex.html#line.331"><B>restart</B></A>(<A HREF="../../javafe/util/CorrelatedReader.html" title="class in javafe.util">CorrelatedReader</A>&nbsp;in)</PRE>
<DL>
<DD>Start scaning a new <code>CorrelatedReader</code>.  First closes
     the old <code>CorrelatedReader</code> associated with
     <code>this</code> (if there was one), and clears out the set of
     collected lexical pragms.  In addition to (re)-seting the
     underlying input stream, this method scans the first token,
     returning the token kind of the result and setting the
     <code>Token</code> fields of <code>this</code>.  If a
     <code>CorrelatedReader</code> is already underlying
     <code>this</code>, it is closed before the new reader is
     installed.  Note: The argument <code>in</code> is "captured" in
     the internal, private state of the resulting scanner and should
     not be used by other parts of the program.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.358"><B>close</B></A>()</PRE>
<DL>
<DD>Closes the <code>CorrelatedReader</code> underlying
     <code>this</code>, clears the set of collected lexical pragmas,
     and in other ways frees up resources associated with
     <code>this</code>.  After being closed, a <code>Lex</code> object
     can be restarted by calling <code>restart</code>.  (An IO
     exception raised by closing the underlying input stream will be
     converted into a <code>javafe.util.FatalError</code> runtime
     exception.)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceLookaheadToken(int, javafe.parser.ParserToken)"><!-- --></A><H3>
replaceLookaheadToken</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.375"><B>replaceLookaheadToken</B></A>(int&nbsp;k,
                                  <A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A>&nbsp;t)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNextToken()"><!-- --></A><H3>
getNextToken</H3>
<PRE>
public int <A HREF="../../src-html/javafe/parser/Lex.html#line.391"><B>getNextToken</B></A>()</PRE>
<DL>
<DD>Scans next token from input stream.  Returns the code of the
     next token in the token stream and fills in the <code>Token</code>
     fields of <CODE>this</CODE>.  Note that the
     <code>startingLoc</code> and <code>endingLoc</code> fields of
     <code>this</code> are not accurate for the end-of-file token.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookahead(int)"><!-- --></A><H3>
lookahead</H3>
<PRE>
public int <A HREF="../../src-html/javafe/parser/Lex.html#line.425"><B>lookahead</B></A>(int&nbsp;k)</PRE>
<DL>
<DD>Returns token type of the <TT>k</TT>th future token, where k=0
     is the current token.  If <code>k</code> is past the end of the
     token stream, <code>TagConstants.EOF</code> is returned.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lookaheadToken(int)"><!-- --></A><H3>
lookaheadToken</H3>
<PRE>
public <A HREF="../../javafe/parser/ParserToken.html" title="class in javafe.parser">ParserToken</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.462"><B>lookaheadToken</B></A>(int&nbsp;k)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLexicalPragmas()"><!-- --></A><H3>
getLexicalPragmas</H3>
<PRE>
public <A HREF="../../javafe/ast/LexicalPragmaVec.html" title="class in javafe.ast">LexicalPragmaVec</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.474"><B>getLexicalPragmas</B></A>()</PRE>
<DL>
<DD>Returns the set of lexical pragmas collected.  It also clears
     the set of lexical pragmas so that the next call will not include
     them.  (If this lexer has no <code>PragmaParser</code>, then an
     empty vector is returned.)
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="popLexicalPragma()"><!-- --></A><H3>
popLexicalPragma</H3>
<PRE>
public <A HREF="../../javafe/ast/LexicalPragma.html" title="class in javafe.ast">LexicalPragma</A> <A HREF="../../src-html/javafe/parser/Lex.html#line.482"><B>popLexicalPragma</B></A>()</PRE>
<DL>
<DD>Remove the first LexicalPragma from our set of lexical pragmas
 collected, returning it or null if our set is empty.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanToken()"><!-- --></A><H3>
scanToken</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.509"><B>scanToken</B></A>()</PRE>
<DL>
<DD>Returns the code of the next token in the token stream, updating
     the <code>Token</code> fields of <code>this</code> along the way.
     Advances underlying stream to the character just past the last
     character of the token returned, and changes the internal buffer
     used by <code>getTokenText</code> to contain the text of this
     token.

     <p> In most cases, this method leaves <code>m_nextchr</code>
     holding the character just after the token scanned and
     <code>m_in</code> pointing to the character after that.  However,
     if <code>TagConstants.C_COMMENT</code> or
     <code>TagConstants.EOL_COMMENT</code> is returned, it leaves
     <code>m_in</code> pointing to the character just after the token
     scanned and <code>m_nextchr</code> undefined.  This aids in pragma
     processing.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanComment(int)"><!-- --></A><H3>
scanComment</H3>
<PRE>
private void <A HREF="../../src-html/javafe/parser/Lex.html#line.610"><B>scanComment</B></A>(int&nbsp;commentKind)</PRE>
<DL>
<DD>Handle a comment.  m_in points to the character just after the
     "//" or "/*".  The mark is set at the last character read.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanCharOrString(int)"><!-- --></A><H3>
scanCharOrString</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.690"><B>scanCharOrString</B></A>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Scan a character or string constant.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanNumber(int)"><!-- --></A><H3>
scanNumber</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.802"><B>scanNumber</B></A>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Scans a numeric literal.  Requires <code>nextchr</code> is a
     decimal digit.  Reads a numeric literal into <code>text</code>.
     Depending on the kind of literal found, will return one of
     <code>TagConstants.INTLIT</code>,
     <code>TagConstants.LONGLIT</code>,
     <code>TagConstants.FLOATLIT</code> or
     <code>TagConstants.DOUBLELIT</code>.  If an error is detected, a
     message is sent to <code>ErrorSet</code>, <code>m_in</code> is
     advanced to what appears to be the end of the erroneous token, and
     a legal literal is left in <code>text</code>.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="finishFloatingPointLiteral(int)"><!-- --></A><H3>
finishFloatingPointLiteral</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.949"><B>finishFloatingPointLiteral</B></A>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Finishes scanning a floating-point literal.

     <p> Requires: <code>text</code> contains a possibly empty sequence
     of decimal digits followed by an optional <code>'.'</code>; also,
     <code>text</code> cannot be empty.  Further, let <i>s</i> be the
     sequence of characters consisting of the characters in
     <code>text</code> followed by <code>nextchr</code> followed by the
     characters in <code>m_in</code>.  This routine requires that a
     prefix of <i>s</i> match the syntax of floating-point literals as
     defined by the Java language specification.

     <p> Ensures: Scans the floating-point literal in <i>s</i>.
     Depending on the type of the literal, returns
     <code>TagConstants.FLOATLIT</code> or
     <code>TagConstants.DOUBLELIT</code> and sets sets
     <code>auxVal</code> to either a <code>Float</code> or
     <code>Double</code>.  If an error is encountered, a message is
     sent to <code>ErorrSet</code> and recovery is performed.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanPunctuation(int)"><!-- --></A><H3>
scanPunctuation</H3>
<PRE>
private int <A HREF="../../src-html/javafe/parser/Lex.html#line.1049"><B>scanPunctuation</B></A>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Scans a punctuation string <em>or</em> a floating-point
     number.  If input doesn't match either a floating-point number or
     any punctuation, returns <code>TagConstants.NULL</code>.  Assumes
     <code>startingLoc</code> already filled in.

     <p>The routine may change the mark arbitrarily.

     <p> This method leaves <code>m_in</code> in a different state than
     the previous ones do.  Ordinarily, <code>scanXXX</code> routines
     return with <code>m_nextchr</code> holding the character just
     after the token scanned and <code>m_in</code> pointing to the
     character after that.  <code>scanPunctuation</code> does too, but
     only when the value returned is <em>not</em>
     <code>TagConstants.C_COMMENT</code> or
     <code>TagConstants.EOL_COMMENT</code>; in those two cases, it
     returns with <code>m_in</code> pointing to the character just
     after the token scanned and <code>m_nextchr</code> undefined.
     This aids in pragma processing.  Also, if <code>TagConstants.NULL</code>
     is returned, then <code>m_nextchr</code> is undefined and
     <code>m_in</code> is where it was on entry.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="scanJavaExtensions(int)"><!-- --></A><H3>
scanJavaExtensions</H3>
<PRE>
protected int <A HREF="../../src-html/javafe/parser/Lex.html#line.1138"><B>scanJavaExtensions</B></A>(int&nbsp;nextchr)</PRE>
<DL>
<DD>Scans a Java extension.  If input doesn't match any Java extension,
     returns <code>TagConstants.NULL</code>.  Assumes <code>startingLoc</code>
     already filled in, and assumes <code>textlen</code> is 0.

     <p>The routine may change the mark arbitrarily.

     <p> If a Java extension is matched, returns with <code>m_nextchr</code>
     holding the character just after the token scanned and <code>m_in</code>
     pointing to the character after that.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="stringLitAppend(int)"><!-- --></A><H3>
stringLitAppend</H3>
<PRE>
private void <A HREF="../../src-html/javafe/parser/Lex.html#line.1155"><B>stringLitAppend</B></A>(int&nbsp;c)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addJavaKeywords()"><!-- --></A><H3>
addJavaKeywords</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.1202"><B>addJavaKeywords</B></A>()</PRE>
<DL>
<DD>Add all of Java's keywords to the scanner.  The token codes used
     for these keywords are those defined by the <code>TagConstants</code>
     class.  Requires that none of these keywords have been added
     already.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addKeyword(java.lang.String, int)"><!-- --></A><H3>
addKeyword</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.1235"><B>addKeyword</B></A>(java.lang.String&nbsp;newkeyword,
                       int&nbsp;code)</PRE>
<DL>
<DD>Add a keyword to a <code>Lex</code> object with the given code.
 Requires that <code>newkeyword</code> is a Java identifier and
 that <code>code</code> is not <code>TagConstants.NULL</code> or
 a tokenType that requires auxVal to be non-null;
 (cf. Token.auxVal).

 Also requires that the keyword hasn't already been added.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addJavaPunctuation()"><!-- --></A><H3>
addJavaPunctuation</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.1255"><B>addJavaPunctuation</B></A>()</PRE>
<DL>
<DD>Add all of Java's punctuation strings to the scanner.  The codes
     used for these punctuation strings are the found in the
     <code>TagConstants</code> class.  Requires that none of these
     punctuation strings have been added before.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addPunctuation(java.lang.String, int)"><!-- --></A><H3>
addPunctuation</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.1285"><B>addPunctuation</B></A>(java.lang.String&nbsp;punctuation,
                           int&nbsp;code)</PRE>
<DL>
<DD>Add a punctuation string to a scanner associated with a given
     code.  Requires that the characters in the punctuation string are
     all punctuation characters, that is, non-alphanumeric ASCII
     characters whose codes are between 33 ('!')  and 126 ('~')
     inclusive.  Also requires that the code is not
     <code>TagConstants.NULL</code> and that the punctuation string
     hasn't already been added.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="zzz(java.lang.String)"><!-- --></A><H3>
zzz</H3>
<PRE>
public void <A HREF="../../src-html/javafe/parser/Lex.html#line.1310"><B>zzz</B></A>(java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD>Checks invariants (assumes that <CODE>Token</CODE> fields
     haven't been mucked with by outside code).  <code>prefix</code> is
     used to prefix error messages with context provided by the
     caller.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lex.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
Javafe<br />&copy; 2010 IT University of Copenhagen<br />&copy; 2007,2008,2009,2010 Joseph Kiniry<br/>&copy; 2003,2004,2005,2006 David Cok and Joseph Kiniry<br />&copy; 2005,2006,2007,2008,2009 University College Dublin<br />&copy; 2003,2004 Radboud University Nijmegen<br />&copy; 1999,2000 Compaq Computer Corporation<br />&copy; 1997,1998,1999 Digital Equipment Corporation<br />All Rights Reserved</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javafe/parser/FileFormatException.html" title="class in javafe.parser"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javafe/parser/Parse.html" title="class in javafe.parser"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?javafe/parser/Lex.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Lex.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<a href="http://kind.ucd.ie/products/opensource/E/">The ESC/Java2 Project Homepage</a>
</BODY>
</HTML>
