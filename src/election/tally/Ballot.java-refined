package election.tally;

/**
 * The Ballot class represents a ballot paper in an Irish election,
 * which uses the Proportional Representation Single Transferable Vote
 * (PRSTV) system.
 * 
 * @author Dermot Cochran
 * @copyright 2005-2009
 * @reviewer Joe Kiniry
 * 
 * @see <a href="http://www.cev.ie/htm/tenders/pdf/1_2.pdf">Department of 
 * Environment and Local Government, Count Requirements and Commentary on Count 
 * Rules, sections 3-14</a>
 */

public class Ballot {
	
  /** 
   * Candidate ID value to use for nontransferable ballot papers.
   * 
   * @design A special candidate ID value is used to indicate
   *   non-transferable votes i.e., when the list of preferences has
   *   been exhausted and none of the continuing candidates are in the
   *   preference list, then the ballot is deemed to be nontransferable.
   *   
   * @see <a href="http://www.cev.ie/htm/tenders/pdf/1_2.pdf">Department of 
   * Environment and Local Government, Count Requirements and Commentary on Count 
   * Rules, section 7, pages 23-27</a> 
   */
  public static final int NONTRANSFERABLE;
  
  /** @review kiniry 8 Feb 2006 - Each of these fields needs at least
   * one invariant, typically.  E.g., can ballotID be negative?  If
   * ballotID is unique per Ballot object, then this needs to be
   * expressed in an invariant.  These examples are below. */

  /** Ballot ID number */
  //@ public static final ghost int NO_ID = 0;
  //@ public invariant (ballotID == NO_ID) || (0 < ballotID);
  protected /*@ spec_public @*/ int ballotID;

  /** Preference list of candidate IDs */
  protected /*@ spec_public non_null @*/ int[] preferenceList;
  
  /** Total number of valid preferences on the ballot paper */
  //@ public invariant 0 <= numberOfPreferences;
  // @design numberOfPreferences == 0 means an empty ballot.
  // @see #ballotID invariant
  protected /*@ spec_public @*/ int numberOfPreferences;
  
  /** Position within preference list */
  //@ public initially positionInList == 0;
  //@ public invariant 0 <= positionInList;
  //@ public invariant positionInList <= numberOfPreferences;
  //@ public constraint \old(positionInList) <= positionInList;
  protected /*@ spec_public @*/ int positionInList;
 

  /** Candidate ID to which the vote is assigned at the end of each count */
  protected /*@ spec_public non_null @*/ int[] candidateIDAtCount;
  
  /** Last count number in which this ballot was transfered */
  /*@ public invariant 0 <= countNumberAtLastTransfer;
    @ public initially countNumberAtLastTransfer == 0;
    @ public invariant countNumberAtLastTransfer <
    @   CountConfiguration.MAXCOUNT;
    @ public constraint \old(countNumberAtLastTransfer) <=
    @   countNumberAtLastTransfer;
    @*/
  protected /*@ spec_public @*/ int countNumberAtLastTransfer;

  /**
   * Default constructor
   */
  /*@ public normal_behavior
    @   assignable numberOfPreferences, countNumberAtLastTransfer;
    @   assignable positionInList, ballotID;
    @   ensures numberOfPreferences == 0;
    @   ensures countNumberAtLastTransfer == 0;
    @   ensures positionInList == 0;
    @*/
  public Ballot();
  
  /**
   * Get the location of the ballot at each count
   * 
   * @param countNumber The round of counting which we need to check
   * @return The candidate ID or the NONTRANSFERABLE constant
   */    
  /*@ public normal_behavior
    @   requires 0 <= countNumber;
    @   requires countNumber <= countNumberAtLastTransfer;
    @   requires countNumber < candidateIDAtCount.length;
    @   ensures \result == candidateIDAtCount[countNumber];
    @
    @ public model pure int getPreferenceAtCount(final int countNumber) {
    @     return candidateIDAtCount[countNumber];
    @ }
    @*/
  
  /**
   * Get the count number for the last transfer of this ballot
   * 
   * @return The last count at which this ballot was transferred
   */    
  /*@ public normal_behavior
    @   ensures \result == countNumberAtLastTransfer;
    @
    @ public model pure int getCountNumberAtLastTransfer(){
    @    return countNumberAtLastTransfer;
    @ }
    @*/
  
  /**
   * Get the first preference vote from this ballot
   * 
   * @design There must always be a first preference vote in each ballot,
   * otherwise the vote is not included and need not be loaded.
   * The quota is calculated from the number of first preference votes,
   * so that empty ballots are not included.
   * 
   * @reference http://www.cev.ie/htm/tenders/pdf/1_2.pdf, section 3, page 12
   * @return The candidate ID of the first preference for this ballot
   */ 
  /*@ public normal_behavior
    @   requires 0 < numberOfPreferences;
    @   requires 0 < preferenceList.length;
    @   ensures \result != NONTRANSFERABLE;
    @   ensures \result == preferenceList[0];
    @
    @ public model pure int getFirstPreference() {
    @   return preferenceList[0];
    @ }
    @*/
  
  /**
   * Load the ballot details
   * 
   * @param candidateIDList List of candidate IDs in order from first
   *   preference
   * 
   * @param listSize Number of candidate IDs in the list
   * 
   * @design There should be at least one preference in the list.
   *   Empty or spoilt votes should neither be loaded nor counted.
   *   There should be no duplicate preferences in the list and none
   *   of the candidate ID values should match the special value for
   *   non transferable votes.
   *   <p> There should be no duplicates in the preference list; but
   *   there is no need to make this a precondition because duplicates
   *   will be ignored and skipped over.
   */
  /*@ public normal_behavior
    @   requires (\forall int i; 0 <= i && i < list.length;
    @     list[i] != NONTRANSFERABLE);
    @   assignable preferenceList;
    @   ensures numberOfPreferences == list.length;
    @   ensures (\forall int i; 0 <= i && i < list.length;
    @     preferenceList[i] == list[i]);
    @*/
  public void load(int[] list);
  
  /**
   * Get candidate ID to which this ballot is assigned
   * 
   * @return The candidate ID to which this ballot is assigned
   */
  /*@ public normal_behavior 
    @   requires 0 <= positionInList;
    @   requires positionInList <= numberOfPreferences;
    @   requires preferenceList != null;
    @   ensures (positionInList == numberOfPreferences) ==> 
    @     (\result == NONTRANSFERABLE);
    @   ensures (positionInList < numberOfPreferences) ==>
    @     (\result == preferenceList[positionInList]);
    @*/
  public /*@ pure @*/ int getCandidateID();
  
  /**
   * Get next preference candidate ID
   * 
   * @param offset The number of preferences to look ahead
   *  
   * @return The next preference candidate ID
   */
  /*@ public normal_behavior 
    @   requires 0 <= positionInList;
    @   requires 1 <= offset;
    @   requires positionInList <= numberOfPreferences;
    @   requires preferenceList != null;
    @   ensures (positionInList + offset >= numberOfPreferences) ==> 
    @     (\result == NONTRANSFERABLE);
    @   ensures (positionInList + offset < numberOfPreferences) ==>
    @     (\result == preferenceList[positionInList + offset]);
    @*/
  public /*@ pure @*/ int getNextPreference(int offset);
  
  /**
   * Transfer this ballot to the next preference candidate
   * 
   * @design This method may be called multiple times during the same
   *   count until the ballot is nontransferable or a continuing
   *   candidate ID is found in the remainder of the preference list.
   * 
   * @param countNumber The count number at which the ballot was
   *   transfered
   */
  /*@ public normal_behavior
    @   requires 0 <= positionInList;
    @   requires positionInList <= numberOfPreferences;
    @   requires countNumberAtLastTransfer <= countNumber;
    @   assignable countNumberAtLastTransfer, positionInList;
    @   ensures (positionInList == \old(positionInList) + 1) ||
    @     (positionInList == numberOfPreferences); 
    @*/
  public void transfer(int countNumber);
  
  /**
   * Get ballot ID number.
   * 
   * @return ID number for this ballot
   */
  /*@ public normal_behavior
    @   ensures \result == ballotID;
    @*/
  public /*@ pure @*/ int getBallotID();
  
  /**
   * This method checks if this ballot paper is assigned to this candidate.
   * 
   * @design It is valid to use <code>NONTRANSFERABLE</code> as the ID value to
   * be checked.  This ballot paper can only be assigned to one candidate at a time;
   * there is no concept of fractional transfers of votes in the Irish electoral
   * system.
   * 
   * @param candidateIDToCheck The unique identifier for this candidate.
   * 
   * @return <code>true</code> if this ballot paper is assigned to this candidate ID
   */
  /*@ public normal_behavior
    @   ensures (\result == true) <==> (getCandidateID() == candidateIDToCheck); 
    @*/
  public /*@ pure @*/ boolean isAssignedTo (int candidateIDToCheck);
  
  /**
   * Gets remaining number of preferences.
   * 
   * @return The number of preferences remaining
   */
  /*@
    @ public normal_behavior
    @   requires positionInList <= numberOfPreferences;
    @   ensures \result == numberOfPreferences - positionInList;
    @*/
  public /*@ pure @*/ int remainingPreferences();
  
}
